<!DOCTYPE html>
<style>
  button {
     background-color: white;
        border: 2px solid black;
        color: green;
        padding: 5px 10px;
        text-align: center;
        display: inline-block;
        font-size: 25px;
        margin: 20px 35px;
        cursor: pointer;
  text-decoration: none;
   transition-duration: 0.4s;

}
 button:hover{
   background-color: black;
  }

</style>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
body {
  font-family: Arial, Helvetica, sans-serif;
}

.navbar {
  overflow: hidden;
  background-color: #333;
}

.navbar a {
  float: left;
  font-size: 16px;
  color: white;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
}

.dropdown {
  float: left;
  overflow: hidden;
}

.dropdown .dropbtn {
  font-size: 16px;  
  border: none;
  outline: none;
  color: white;
  padding: 14px 16px;
  background-color: inherit;
  font-family: inherit;
  margin: 0;
}

.navbar a:hover, .dropdown:hover .dropbtn {
  background-color: green;
}

.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f9f9f9;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}

.dropdown-content a {
  float: none;
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
  text-align: left;
}

.dropdown-content a:hover {
  background-color: #ddd;
}

.dropdown:hover .dropdown-content {
  display: block;
}
</style>
</head>
<body>

<div class="navbar">
  <a href="index.html">Home</a>
 
  <div class="dropdown">
    <button class="dropbtn">Topics
      <i class="fa fa-caret-down"></i>
    </button>
    <div class="dropdown-content">
      <a href="1ds.html">Advantages & operation of DS</a>
      <a href="2ds.html">Data Structure & Algo</a>
      <a href="asymptotic.html">Asymptoyic Analysis</a>
      <a href="array.html">Array</a>
       <a href="pointer.html">Pointer</a>
      <a href="ll.html">Linked List</a>
      <a href="stack.html">Stack & Queue</a>
      
      <a href="tree.html">Tree</a>
      <a href="tree1.html">Implementation of tree</a>
       <a href="Binary.html">Binary Tree</a>
      <a href="bst.html">BST</a>
      <a href="avl.html">AVL Tree</a>
       <a href="Btree.html">B Tree</a>
        <a href="b+tree.html">B+ Tree</a>
        <a href="graph.html">Graphs</a>
    </div>
  </div> 
</div>
<h1>AVL Tree</h1>
<p>
AVL Tree is invented by GM Adelson - Velsky and EM Landis in 1962. The tree is named AVL in honour of its inventors.
<br><br>
AVL Tree can be defined as height balanced binary search tree in which each node is associated with a balance factor which is calculated by subtracting the height of its right sub-tree from that of its left sub-tree.
<br><br>
Tree is said to be balanced if balance factor of each node is in between -1 to 1, otherwise, the tree will be unbalanced and need to be balanced.
<br><br>
<center><b style="font-size:25px;color:
#572735;">Balance Factor (k) = height (left(k)) - height (right(k))</b></center>
<br> <br>
If balance factor of any node is 1, it means that the left sub-tree is one level higher than the right sub-tree.
<br><br>
If balance factor of any node is 0, it means that the left sub-tree and right sub-tree contain equal height.
<br><br>
If balance factor of any node is -1, it means that the left sub-tree is one level lower than the right sub-tree.
<br><br>
An AVL tree is given in the following figure. We can see that, balance factor associated with each node is in between -1 and +1
<br><br>
</p>
<center><img  src="https://www.codesdope.com/staticroot/images/ds/avl1.png"   width="450" height="300"></center>
<h3>Complexity</h3>
<img src="https://global-uploads.webflow.com/5d0dc87aac109e1ffdbe379c/6135f17b6b064d36f889cd44_time-complexity-of-avl-tree.jpg">

<h3>Operations on AVL tree</h3>
<p>
Due to the fact that, AVL tree is also a binary search tree therefore, all the operations are performed in the same way as they are performed in a binary search tree. Searching and traversing do not lead to the violation in property of AVL tree. However, insertion and deletion are the operations which can violate this property and therefore, they need to be revisited.
</p>

<h3>1) Insertion</h3>
<p>Insertion in AVL tree is performed in the same way as it is performed in a binary search tree. However, it may lead to violation in the AVL tree property and therefore the tree may need balancing. The tree can be balanced by applying rotations.</p>

<h3>2) Deletion </h3>
<p>Deletion can also be performed in the same way as it is performed in a binary search tree. Deletion may also disturb the balance of the tree therefore, various types of rotations are used to rebalance the tree.</p>


<h3>Why AVL Tree?</h3>
<p>
AVL tree controls the height of the binary search tree by not letting it to be skewed. The time taken for all operations in a binary search tree of height h is O(h). However, it can be extended to O(n) if the BST becomes skewed (i.e. worst case). By limiting this height to log n, AVL tree imposes an upper bound on each operation to be O(log n) where n is the number of nodes.

</p>
<br>
<h3>AVL Rotations</h3><p>
We perform rotation in AVL tree only in case if Balance Factor is other than -1, 0, and 1. There are basically four types of rotations which are as follows:
<br><br>
    L L rotation: Inserted node is in the left subtree of left subtree of A<br>
    R R rotation : Inserted node is in the right subtree of right subtree of A<br>
    L R rotation : Inserted node is in the right subtree of left subtree of A<br>
    R L rotation : Inserted node is in the left subtree of right subtree of A<br>

</p>

<h3>1. RR Rotation</h3>
<p>
When BST becomes unbalanced, due to a node is inserted into the right subtree of the right subtree of A, then we perform RR rotation, RR rotation is an anticlockwise rotation, which is applied on the edge below a node having balance factor -2
</p>
<img src="https://www.codingeek.com/wp-content/uploads/2017/04/LL-300x151.png"  width="450" height="300">
<p>In above example, node A has balance factor -2 because a node C is inserted in the right subtree of A right subtree. We perform the RR rotation on the edge below A.</p>
<h3>2. LL Rotation</h3>
<p>
When BST becomes unbalanced, due to a node is inserted into the left subtree of the left subtree of C, then we perform LL rotation, LL rotation is clockwise rotation, which is applied on the edge below a node having balance factor 2.
</p>
<img src="https://www.codingeek.com/wp-content/uploads/2017/04/RR-300x130.png" width="450" height="300">

<h3>3. LR Rotation</h3>
<p>
Double rotations are bit tougher than single rotation which has already explained above. LR rotation = RR rotation + LL rotation, i.e., first RR rotation is performed on subtree and then LL rotation is performed on full tree, by full tree we mean the first node from the path of inserted node whose balance factor is other than -1, 0, or 1.</p>

<p>Shown below is the case of LR rotation, here two rotations are performed. First RR and then, LL as follows,<br><br>

    Right rotation is applied at 70, after restructuring, 60 takes the place of 70 and 70 as the right child of 60.<br>
    Now left rotation is required at the root 50, 60 becomes the root. 50 and 70 become the left and right child respectively.</p>

<img src="https://www.codingeek.com/wp-content/uploads/2017/05/LR.png" width="450" height="300">
<p>We could also think of the shown way to balance quickly rather than going with two rotations.</p>
<img src="https://www.codingeek.com/wp-content/uploads/2017/04/RL-roatation.png" width="450" height="300">

<h3>4. RL Rotation</h3>
<p>
As already discussed, that double rotations are bit tougher than single rotation which has already explained above. R L rotation = LL rotation + RR rotation, i.e., first LL rotation is performed on subtree and then RR rotation is performed on full tree, by full tree we mean the first node from the path of inserted node whose balance factor is other than -1, 0, or 1.</p><br>
<p>below is the case of RL rotation, here two rotations are performed. First LL and then, RR as follows,
<br><br>
    Left rotation is applied at 30, after restructuring 40 takes the place of 30 and 30 as the left child of 40.<br>
    Now right rotation is required at the root 50, 40 becomes root. 30 and 50 becomes the left and right child respectively.</p>
    <br>
    <img src="https://www.codingeek.com/wp-content/uploads/2017/05/RL.png" width="450" height="300">
    
    <br><br>
<a href="https://gungungupta7525.github.io/Data-structure/bst.html"  style="font-size:30;"><button>Previous</button></a>
<a href="https://gungungupta7525.github.io/Data-structure/Btree.html"  style="font-size:30; float:right;"><button>NEXT</button></a>

</body>
