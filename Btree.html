<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
body {
  font-family: Arial, Helvetica, sans-serif;
}

.navbar {
  overflow: hidden;
  background-color: #333;
}

.navbar a {
  float: left;
  font-size: 16px;
  color: white;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
}

.dropdown {
  float: left;
  overflow: hidden;
}

.dropdown .dropbtn {
  font-size: 16px;  
  border: none;
  outline: none;
  color: white;
  padding: 14px 16px;
  background-color: inherit;
  font-family: inherit;
  margin: 0;
}

.navbar a:hover, .dropdown:hover .dropbtn {
  background-color: green;
}

.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f9f9f9;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}

.dropdown-content a {
  float: none;
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
  text-align: left;
}

.dropdown-content a:hover {
  background-color: #ddd;
}

.dropdown:hover .dropdown-content {
  display: block;
}
</style>
</head>
<body>

<div class="navbar">
  <a href="index.html">Home</a>
 
  <div class="dropdown">
    <button class="dropbtn">Topics
      <i class="fa fa-caret-down"></i>
    </button>
    <div class="dropdown-content">
      <a href="1ds.html">Advantages & operation of DS</a>
      <a href="2ds.html">Data Structure & Algo</a>
      <a href="asymptotic.html">Asymptoyic Analysis</a>
      <a href="array.html">Array</a>
       <a href="pointer.html">Pointer</a>
      <a href="ll.html">Linked List</a>
      <a href="stack.html">Stack & Queue</a>
      
      <a href="tree.html">Tree</a>
      <a href="tree1.html">Implementation of tree</a>
       <a href="Binary.html">Binary Tree</a>
      <a href="bst.html">BST</a>
      <a href="avl.html">AVL Tree</a>
       <a href="btree.html">B Tree</a>
        <a href="b+tree.html">B+ Tree</a>
        <a href="graph.html">Graphs</a>
    </div>
  </div> 
</div>


<h1>B Tree</h1>
<p>
B Tree is a specialized m-way tree that can be widely used for disk access. A B-Tree of order m can have at most m-1 keys and m children. One of the main reason of using B tree is its capability to store large number of keys in a single node and large key values by keeping the height of the tree relatively small.<br>
<br>
A B tree of order m contains all the properties of an M way tree. In addition, it contains the following properties.
<br><br>
    Every node in a B-Tree contains at most m children.<br>
    Every node in a B-Tree except the root node and the leaf node contain at least m/2 children.<br>
    The root nodes must have at least 2 nodes.<br>
    All leaf nodes must be at the same level.<br>
<br>
It is not necessary that, all the nodes contain the same number of children but, each node must have m/2 number of nodes<br>

</p>
<h2>Operations</h2>
<h3>Searching :</h3>
<p>
Searching in B Trees is similar to that in Binary search tree. For example, if we search for an item 49 in the following B Tree. The process will something like following :<br><br>

    Compare item 49 with root node 78. since 49 < 78 hence, move to its left sub-tree.<br>
    Since, 40<49<56, traverse right sub-tree of 40.<br>
    49>45, move to right. Compare 49.<br>
    match found, return.
<br>
Searching in a B tree depends upon the height of the tree. The search algorithm takes O(log n) time to search any element in a B tree. <br>
</p>
<img src="https://static.javatpoint.com/ds/images/b-tree-searching.png">
<h3>Inserting</h3>
<p>
Insertions are done at the leaf node level. The following algorithm needs to be followed in order to insert an item into B Tree.
<br><br>
   1) Traverse the B Tree in order to find the appropriate leaf node at which the node can be inserted.,br>
    2) If the leaf node contain less than m-1 keys then insert the element in the increasing order.<br>
    3) Else, if the leaf node contains m-1 keys, then follow the following steps.<br>
       4) Insert the new element in the increasing order of elements.<br>
      5)  Split the node into the two nodes at the median.<br>
        6) Push the median element upto its parent node.<br>
        7) If the parent node also contain m-1 number of keys, then split it too by following the same steps.<br>
        <p>Example:

Insert the node 8 into the B Tree of order 5 shown in the following image. </p>
<img src="https://static.javatpoint.com/ds/images/b-tree-inserting.png">
<p>8 will be inserted to the right of 5, therefore insert 8.</p>
<img src="https://static.javatpoint.com/ds/images/b-tree-inserting2.png">
<p>The node, now contain 5 keys which is greater than (5 -1 = 4 ) keys. Therefore split the node from the median i.e. 8 and push it up to its parent node shown as follows.</p>
<img src="https://static.javatpoint.com/ds/images/b-tree-inserting3.png">


<h3>Deletion</h3>
<p>
Deletion is also performed at the leaf nodes. The node which is to be deleted can either be a leaf node or an internal node. Following algorithm needs to be followed in order to delete a node from a B tree.<br>
<br>
   1) Locate the leaf node.<br>
   2)  If there are more than m/2 keys in the leaf node then delete the desired key from the node.<br>
  3)  If the leaf node doesn't contain m/2 keys then complete the keys by taking the element from eight or left sibling.<br>
          .)    If the left sibling contains more than m/2 elements then push its largest element up to its parent and move the intervening element down to the node where the key is deleted.<br>
           .) If the right sibling contains more than m/2 elements then push its smallest element up to the parent and move intervening element down to the node where the key is deleted.<br>
   4) If neither of the sibling contain more than m/2 elements then create a new leaf node by joining two leaf nodes and the intervening element of the parent node.<br>
   5) If parent is left with less than m/2 nodes then, apply the above process on the parent too.
<br><br>
If the the node which is to be deleted is an internal node, then replace the node with its in-order successor or predecessor. Since, successor or predecessor will always be on the leaf node hence, the process will be similar as the node is being deleted from the leaf node.
<br><br>
Example 1
<br>
Delete the node 53 from the B Tree of order 5 shown in the following figure. </p>
<img src="https://static.javatpoint.com/ds/images/b-tree-deletion.png">
<p>53 is present in the right child of element 49. Delete it. </p>
<img src="https://static.javatpoint.com/ds/images/b-tree-deletion2.png">
<p>Now, 57 is the only element which is left in the node, the minimum number of elements that must be present in a B tree of order 5, is 2. it is less than that, the elements in its left and right sub-tree are also not sufficient therefore, merge it with the left sibling and intervening element of parent i.e. 49.<br><br>

The final B tree is shown as follows. </p>
<img src="https://static.javatpoint.com/ds/images/b-tree-deletion3.png">
<br>
<h3>Application of B tree</h3>
<p>
B tree is used to index the data and provides fast access to the actual data stored on the disks since, the access to value stored in a large<br> database that is stored on a disk is a very time consuming process.
<br><br>
Searching an un-indexed and unsorted database containing n key values needs O(n) running time in worst case. However, if we use B Tree to index this database, it will be searched in O(log n) time in worst case. 
</p>



<a href="https://gungungupta7525.github.io/Data-structure/avl.html"  style="font-size:30;">Previous</a>
<a href="https://gungungupta7525.github.io/Data-structure/b+tree.html"  style="font-size:30; float:right;">NEXT</a>



</body>
        </html>
