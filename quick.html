    <div class="dropdown-content">
      <a href="1ds.html">Advantages & operation of DS</a>
      <a href="2ds.html">Data Structure & Algo</a>
     <a href="asymptotic.html">Asymptotic Analysis</a>
      <a href="array.html">Array</a>
       <a href="pointer.html">Pointer</a>
      <a href="ll.html">Linked List</a>
      <a href="stack.html">Stack & Queue</a>
      
      <a href="tree.html">Tree</a>
      <a href="tree1.html">Implementation of tree</a>
       <a href="Binary.html">Binary Tree</a>
      <a href="bst.html">BST</a>
      <a href="avl.html">AVL Tree</a>
       <a href="Btree.html">B Tree</a>
        <a href="b+tree.html">B+ Tree</a>
        <a href="graph.html">Graphs</a>
          <a href="bubblesort.html">Bubble Sort Algo</a>
          <a href="insert.html">Insertion Sort Algo</a>
         <a href="selection.html">Selection Sort</a>
          <a href="qucik.html">Quick Sort Algo</a>
          <a href="heap.html">Heap Sort Algo</a>
          <a href="radix.html">Radix Sort Algo</a>
          
    </div>
<h1>Quick Sort Algorithm</h1>
<p>
In this article, we will discuss the Quicksort Algorithm. The working procedure of Quicksort is also simple. This article will be very helpful and interesting to students as they might face quicksort as a question in their examinations. So, it is important to discuss the topic.
<br><br>
Sorting is a way of arranging items in a systematic manner. Quicksort is the widely used sorting algorithm that makes n log n comparisons in average case for sorting an array of n elements. It is a faster and highly efficient sorting algorithm. This algorithm follows the divide and conquer approach. Divide and conquer is a technique of breaking down the algorithms into subproblems, then solving the subproblems, and combining the results back together to solve the original problem.
<br><br>
<b>Divide:</b> In Divide, first pick a pivot element. After that, partition or rearrange the array into two sub-arrays such that each element in the left sub-array is less than or equal to the pivot element and each element in the right sub-array is larger than the pivot element.<br><br>
<b>Conquer:</b> Recursively, sort two subarrays with Quicksort.</p>
<p><b>Combine:</b>Combine the already sorted array.
<br><br>
Quicksort picks an element as pivot, and then it partitions the given array around the picked pivot element. In quick sort, a large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot.
<br><br>
After that, left and right sub-arrays are also partitioned using the same approach. It will continue until the single element remains in the sub-array.</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort.png">
<h3>Choosing the pivot</h3>
<p>
Picking a good pivot is necessary for the fast implementation of quicksort. However, it is typical to determine a good pivot. Some of the ways of choosing a pivot are as follows -
<br><br>
   1)  Pivot can be random, i.e. select the random pivot from the given array.<br>
   2)  Pivot can either be the rightmost element of the leftmost element of the given array.<br>
    3) Select median as the pivot element.<br>
</p>


<b>Algorithm:</b>
<pre>
    QUICKSORT (array A, start, end)     
    {  
     1 if (start < end)     
     2 {  
    3 p = partition(A, start, end)  
    4 QUICKSORT (A, start, p - 1)    
    5 QUICKSORT (A, p + 1, end)    
    6 }   
    }  </pre>

<b>Partition Algorithm:</b>
<pre>
The partition algorithm rearranges the sub-arrays in a place.

    PARTITION (array A, start, end)     
    {  
     1 pivot ? A[end]     
     2 i ? start-1     
     3 for j ? start to end -1 {  
     4 do if (A[j] < pivot) {    
     5 then i ? i + 1     
     6 swap A[i] with A[j]   
     7  }}   
     8 swap A[i+1] with A[end]     
     9 return i+1  
    }  
    </pre>
    <h3>Working of Quick Sort Algorithm</h3>
    <p>To understand the working of quick sort, let's take an unsorted array. It will make the concept more clear and understandable.
<br><br>
Let the elements of array are -</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort2.png">
<p>In the given array, we consider the leftmost element as pivot. So, in this case, a[left] = 24, a[right] = 27 and a[pivot] = 24.
<br><br>
Since, pivot is at left, so algorithm starts from right and move towards left.
</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort3.png">
<p>Now, a[pivot] < a[right], so algorithm moves forward one position towards left, i.e. -</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort4.png">
<p>Now, a[left] = 24, a[right] = 19, and a[pivot] = 24.
<br><br>
Because, a[pivot] > a[right], so, algorithm will swap a[pivot] with a[right], and pivot moves to right</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort5.png">
<p>Now, a[left] = 19, a[right] = 24, and a[pivot] = 24. Since, pivot is at right, so algorithm starts from left and moves to right.
<br><br>
As a[pivot] > a[left], so algorithm moves one position to right as -</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort6.png">
<p>Now, a[left] = 9, a[right] = 24, and a[pivot] = 24. As a[pivot] > a[left], so algorithm moves one position to right as -</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort7.png">
<p>Now, a[left] = 29, a[right] = 24, and a[pivot] = 24. As a[pivot] < a[left], so, swap a[pivot] and a[left], now pivot is at left, i.e. -</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort8.png">
<p>Since, pivot is at left, so algorithm starts from right, and move to left. Now, a[left] = 24, a[right] = 29, and a[pivot] = 24. As a[pivot] < a[right], so algorithm moves one position to left, as -</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort9.png">
<p>Now, a[pivot] = 24, a[left] = 24, and a[right] = 14. As a[pivot] > a[right], so, swap a[pivot] and a[right], now pivot is at right, i.e. -</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort10.png">
<p>Now, a[pivot] = 24, a[left] = 14, and a[right] = 24. Pivot is at right, so the algorithm starts from left and move to right.</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort11.png">
<p>Now, a[pivot] = 24, a[left] = 24, and a[right] = 24. So, pivot, left and right are pointing the same element. It represents the termination of procedure.<br><br>

Element 24, which is the pivot element is placed at its exact position.
<br><br>
Elements that are right side of element 24 are greater than it, and the elements that are left side of element 24 are smaller than it.</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort12.png">
<p>Now, in a similar manner, quick sort algorithm is separately applied to the left and right sub-arrays. After sorting gets done, the array will be -</p>
<img src="https://static.javatpoint.com/ds/images/quick-sort13.png">
<h2>Quicksort complexity</h2>
<h3>1. Time Complexity</h3>
<p>
   <b> Best Case Complexity -</b> In Quicksort, the best-case occurs when the pivot element is the middle element or near to the middle element. The best-case time complexity of quicksort is O(n*logn).<br><br>
   <b> Average Case Complexity - </b>It occurs when the array elements are in jumbled order that is not properly ascending and not properly descending. The average case time complexity of quicksort is O(n*logn).<br><br>
    <b> Worst Case Complexity - </b>In quick sort, worst case occurs when the pivot element is either greatest or smallest element. Suppose, if the pivot element is always the last element of the array, the worst case would occur when the given array is sorted already in ascending or descending order. The worst-case time complexity of quicksort is O(n2).
<br><br><br>
Though the worst-case complexity of quicksort is more than other sorting algorithms such as Merge sort and Heap sort, still it is faster in practice. Worst case in quick sort rarely occurs because by changing the choice of pivot, it can be implemented in different ways. Worst case in quicksort can be avoided by choosing the right pivot element.</p>
<h3>2. Space Complexity</h3>
<p>The space complexity of quicksort is O(n*logn).</p>
<h2>Implementation of quicksort</h2>
<b>Program: Write a program to implement quicksort in Java.</b>
<code><pre  style="background-color:#f3daff;">
    public class Quick  
    {  
        /* function that consider last element as pivot,  
    place the pivot at its exact position, and place  
    smaller elements to left of pivot and greater  
    elements to right of pivot.  */  
    int partition (int a[], int start, int end)  
    {  
        int pivot = a[end]; // pivot element  
        int i = (start - 1);  
      
        for (int j = start; j <= end - 1; j++)  
        {  
            // If current element is smaller than the pivot  
            if (a[j] < pivot)  
            {  
                i++; // increment index of smaller element  
                int t = a[i];  
                a[i] = a[j];  
                a[j] = t;  
            }  
        }  
        int t = a[i+1];  
        a[i+1] = a[end];  
        a[end] = t;  
        return (i + 1);  
    }  
      
    /* function to implement quick sort */  
    void quick(int a[], int start, int end) /* a[] = array to be sorted, start = Starting index, end = Ending index */  
    {  
        if (start < end)  
        {  
            int p = partition(a, start, end);  //p is partitioning index  
            quick(a, start, p - 1);  
            quick(a, p + 1, end);  
        }  
    }  
      
    /* function to print an array */  
    void printArr(int a[], int n)  
    {  
        int i;  
        for (i = 0; i < n; i++)  
            System.out.print(a[i] + " ");  
    }  
        public static void main(String[] args) {  
        int a[] = { 13, 18, 27, 2, 19, 25 };  
        int n = a.length;  
        System.out.println("\nBefore sorting array elements are - ");  
        Quick q1 = new Quick();  
        q1.printArr(a, n);  
        q1.quick(a, 0, n - 1);  
        System.out.println("\nAfter sorting array elements are - ");  
        q1.printArr(a, n);  
        System.out.println();  
        }  
    }  </code></pre>
</body>
