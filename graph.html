<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
body {
  font-family: Arial, Helvetica, sans-serif;
}

.navbar {
  overflow: hidden;
  background-color: #333;
}

.navbar a {
  float: left;
  font-size: 16px;
  color: white;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
}

.dropdown {
  float: left;
  overflow: hidden;
}

.dropdown .dropbtn {
  font-size: 16px;  
  border: none;
  outline: none;
  color: white;
  padding: 14px 16px;
  background-color: inherit;
  font-family: inherit;
  margin: 0;
}

.navbar a:hover, .dropdown:hover .dropbtn {
  background-color: green;
}

.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f9f9f9;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}

.dropdown-content a {
  float: none;
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
  text-align: left;
}

.dropdown-content a:hover {
  background-color: #ddd;
}

.dropdown:hover .dropdown-content {
  display: block;
}
</style>
</head>
<body>

<div class="navbar">
  <a href="index.html">Home</a>
 
  <div class="dropdown">
    <button class="dropbtn">Topics
      <i class="fa fa-caret-down"></i>
    </button>
    <div class="dropdown-content">
      <a href="1ds.html">Advantages & operation of DS</a>
      <a href="2ds.html">Data Structure & Algo</a>
      <a href="asymptotic.html">Asymptoyic Analysis</a>
      <a href="array.html">Array</a>
       <a href="pointer.html">Pointer</a>
      <a href="ll.html">Linked List</a>
      <a href="stack.html">Stack & Queue</a>
      
      <a href="tree.html">Tree</a>
      <a href="tree1.html">Implementation of tree</a>
       <a href="Binary.html">Binary Tree</a>
      <a href="bst.html">BST</a>
      <a href="avl.html">AVL Tree</a>
       <a href="Btree.html">B Tree</a>
        <a href="b+tree.html">B+ Tree</a>
        <a href="graph.html">Graphs</a>
    </div>
  </div> 
</div>
<h1>Graph</h1>
<p>
A graph can be defined as group of vertices and edges that are used to connect these vertices. A graph can be seen as a cyclic tree, where the vertices (Nodes) maintain any complex relationship among them instead of having parent child relationship.
Definition<br>
<br>
A graph G can be defined as an ordered set G(V, E) where V(G) represents the set of vertices and E(G) represents the set of edges which are used to connect these vertices.<br></p>
<h3>
 Directed and Undirected Graph</h3>
<p>
A graph can be directed or undirected. However, in an undirected graph, edges are not associated with the directions with them. An undirected graph is shown in the above figure since its edges are not attached with any of the directions. If an edge exists between vertex A and B then the vertices can be traversed from B to A as well as A to B.
<br>
In a directed graph, edges form an ordered pair. Edges represent a specific path from some vertex A to another vertex B. Node A is called initial node while node B is called terminal node.</p>
<img src="https://static.javatpoint.com/ds/images/directed-and-undirected-graph.png" alt="Directed Graph">

<h2>Graph Terminology</h2>
<h3>Path</h3>
<p>
A path can be defined as the sequence of nodes that are followed in order to reach some terminal node V from the initial node U.
<h3> Closed Path</h3>
</p>
A path will be called as closed path if the initial node is same as terminal node. A path will be closed path if V0=VN.
<h3>Simple Path
</h3>
<p>
If all the nodes of the graph are distinct with an exception V0=VN, then such path P is called as closed simple path.</p>
<h3>Cycle</h3>
<p>
A cycle can be defined as the path which has no repeated edges or vertices except the first and last vertices.</p>
<h3>Connected Graph
</h3>
<p>
A connected graph is the one in which some path exists between every two vertices (u, v) in V. There are no isolated nodes in connected graph.</p>
<h3>Complete Graph</h3>
<p>
A complete graph is the one in which every node is connected with all other nodes. A complete graph contain n(n-1)/2 edges where n is the number of nodes in the graph.</p>
<h3>Weighted Graph</h3>
<p>
In a weighted graph, each edge is assigned with some data such as length or weight. The weight of an edge e can be given as w(e) which must be a positive (+) value indicating the cost of traversing the edge.</p>
<h3>Digraph</h3>
<p>
A digraph is a directed graph in which each edge of the graph is associated with some direction and the traversing can be done only in the specified direction.</p>
<h3>Loop</h3>
<p>
An edge that is associated with the similar end points can be called as Loop.</p>
<h3>Adjacent Nodes</h3>
<p>
If two nodes u and v are connected via an edge e, then the nodes u and v are called as neighbours or adjacent nodes.</p>
<h3>Degree of the Node</h3>
<p>
A degree of a node is the number of edges that are connected with that node. A node with degree 0 is called as isolated node.
</p>



<h2>Graph representation</h2>
<p>
In this article, we will discuss the ways to represent the graph. By Graph representation, we simply mean the technique to be used to store some graph into the computer's memory.</p>
<p><br>
A graph is a data structure that consist a sets of vertices (called nodes) and edges. There are two ways to store Graphs into the computer's memory:
<br>
    <b>Sequential representation</b> (or, Adjacency matrix representation)<br>
   <b> Linked list representation</b> (or, Adjacency list representation)
</p>

<p>
In sequential representation, an adjacency matrix is used to store the graph. Whereas in linked list representation, there is a use of an adjacency list to store the graph.
<br><br>
In this tutorial, we will discuss each one of them in detail.
<br><br>
Now, let's start discussing the ways of representing a graph in the data structure.
<h3>Sequential representation</h3>
In sequential representation, there is a use of an adjacency matrix to represent the mapping between vertices and edges of the graph. We can use an adjacency matrix to represent the undirected graph, directed graph, weighted directed graph, and weighted undirected graph.
<br><br>
If adj[i][j] = w, it means that there is an edge exists from vertex i to vertex j with weight w.
<br><br>
An entry Aij in the adjacency matrix representation of an undirected graph G will be 1 if an edge exists between Vi and Vj. If an Undirected Graph G consists of n vertices, then the adjacency matrix for that graph is n x n, and the matrix A = [aij] can be defined as -
<br><br>
aij = 1 {if there is a path exists from Vi to Vj}
<br><br>
aij = 0 {Otherwise}
<br><br>
It means that, in an adjacency matrix, 0 represents that there is no association exists between the nodes, whereas 1 represents the existence of a path between two edges.
<br><br>
If there is no self-loop present in the graph, it means that the diagonal entries of the adjacency matrix will be 0.
<br>
Now, let's see the adjacency matrix representation of an undirected graph.</p>
<img src="https://static.javatpoint.com/ds/images/graph-representation.png">
<p>
In the above figure, an image shows the mapping among the vertices (A, B, C, D, E), and this mapping is represented by using the adjacency matrix.
<br>
There exist different adjacency matrices for the directed and undirected graph. In a directed graph, an entry Aij will be 1 only when there is an edge directed from Vi to Vj.<br>
<h3>Adjacency matrix for a directed graph</h3>

In a directed graph, edges represent a specific path from one vertex to another vertex. Suppose a path exists from vertex A to another vertex B; it means that node A is the initial node, while node B is the terminal node.
<br><br>
Consider the below-directed graph and try to construct the adjacency matrix of it.</p>

<img src="https://static.javatpoint.com/ds/images/graph-representation2.png">
<p>In the above graph, we can see there is no self-loop, so the diagonal entries of the adjacent matrix are 0.</p>

<h3>Adjacency matrix for a weighted directed graph</h3>
<p>
It is similar to an adjacency matrix representation of a directed graph except that instead of using the '1' for the existence of a path, here we have to use the weight associated with the edge. The weights on the graph edges will be represented as the entries of the adjacency matrix. We can understand it with the help of an example. Consider the below graph and its adjacency matrix representation. In the representation, we can see that the weight associated with the edges is represented as the entries in the adjacency matrix.</p>
<img src="https://static.javatpoint.com/ds/images/graph-representation3.png"><p>
In the above image, we can see that the adjacency matrix representation of the weighted directed graph is different from other representations. It is because, in this representation, the non-zero values are replaced by the actual weight assigned to the edges.
<br><br>
Adjacency matrix is easier to implement and follow. An adjacency matrix can be used when the graph is dense and a number of edges are large.
<br><br>
Though, it is advantageous to use an adjacency matrix, but it consumes more space. Even if the graph is sparse, the matrix still consumes the same space.</p>
<h3>Linked list representation</h3>
<p>
An adjacency list is used in the linked representation to store the Graph in the computer's memory. It is efficient in terms of storage as we only have to store the values for edges.
<br><br>
Let's see the adjacency list representation of an undirected graph.</p>
<img src="https://static.javatpoint.com/ds/images/graph-representation4.png">
<p>In the above figure, we can see that there is a linked list or adjacency list for every node of the graph. From vertex A, there are paths to vertex B and vertex D. These nodes are linked to nodes A in the given adjacency list.

An adjacency list is maintained for each node present in the graph, which stores the node value and a pointer to the next adjacent node to the respective node. If all the adjacent nodes are traversed, then store the NULL in the pointer field of the last node of the list.
<br><br>
The sum of the lengths of adjacency lists is equal to twice the number of edges present in an undirected graph.
<br><br>
Now, consider the directed graph, and let's see the adjacency list representation of that graph.</p>

<img src="https://static.javatpoint.com/ds/images/graph-representation5.png">
<p>For a directed graph, the sum of the lengths of adjacency lists is equal to the number of edges present in the graph.
<br><br>
Now, consider the weighted directed graph, and let's see the adjacency list representation of that graph</p>

<img src="https://static.javatpoint.com/ds/images/graph-representation6.png">

<p>
In the case of a weighted directed graph, each node contains an extra field that is called the weight of the node.
<br><br>
In an adjacency list, it is easy to add a vertex. Because of using the linked list, it also saves space.
Implementation of adjacency matrix representation of Graph
<br><br>
Now, let's see the implementation of adjacency matrix representation of graph in C.
<br><br>
In this program, there is an adjacency matrix representation of an undirected graph. It means that if there is an edge exists from vertex A to vertex B, there will also an edge exists from vertex B to vertex A.
<br><br>
Here, there are four vertices and five edges in the graph that are non-directed.
<br><br><br>
    /* Adjacency Matrix representation of an undirected graph in C */  
     <pre  style="background-color:#f3e5dc;">
    #include <stdio.h>  
    #define V 4 /* number of vertices in the graph */  
      
    /* function to initialize the matrix to zero */  
    void init(int arr[][V]) {  
      int i, j;  
      for (i = 0; i < V; i++)  
        for (j = 0; j < V; j++)  
          arr[i][j] = 0;  
    }  
      
    /* function to add edges to the graph */  
    void insertEdge(int arr[][V], int i, int j) {  
      arr[i][j] = 1;  
      arr[j][i] = 1;  
    }  
      
    /* function to print the matrix elements */  
    void printAdjMatrix(int arr[][V]) {  
      int i, j;  
      for (i = 0; i < V; i++) {  
        printf("%d: ", i);  
        for (j = 0; j < V; j++) {  
          printf("%d ", arr[i][j]);  
        }  
        printf("\n");  
      }  
    }  
      
    int main() {  
      int adjMatrix[V][V];  
      
      init(adjMatrix);  
      insertEdge(adjMatrix, 0, 1);  
      insertEdge(adjMatrix, 0, 2);  
      insertEdge(adjMatrix, 1, 2);  
      insertEdge(adjMatrix, 2, 0);  
      insertEdge(adjMatrix, 2, 3);  
      
      printAdjMatrix(adjMatrix);  
      
      return 0;  
    }  </pre>




































</body>
