<!DOCTYPE html>
<html>
    <body>
        <h1>Complexity table</h1>
        <table border>
            <tr>
                <th>S.no</th>
                <th>Complexity</th>
                <th>Average Case</th>
                <th>Worst Case</th>           
             </tr>
             <tr>
                <th>1</th>
                <th>Access Complexity</th>
                <th>o(log n)</th>
                <th>o(n)</th>
             </tr>
             <tr>
                <th>2</th>
                <th>Search Complexity</th>
                <th>o(log n)</th>
                <th>o(n)</th>
             </tr>
             <tr>
                <th>3</th>
                <th>Delete Complexity</th>
                <th>o(log n)</th>
                <th>o(n)</th>
             </tr> 
             <tr>
                <th>4</th>
                <th>Insert Complexity</th>
                <th>o(log n)</th>
                <th>o(n)</th>
             </tr>
             <tr>
                <th>5</th>
                <th>Space Complexity</th>
                <th>-</th>
                <th>o(nlogn)</th>
             </tr>
        </table>
        <h2>Basic operations and its algonthms :- </h2>
         <p> <b><u>Insertion operation </u></b>:- It is used to add new node a particular location in a specific situation.<br>
           <b><u>Deletion operation</u></b> :- It is used to delete a node in a specific situation. <br>
            <b><u>search operation</u></b> :-  The search operation is used to search a particular node in a skip list.
         </p>
        <h2>Algorithm of insertion operation :- </h2>
        <p>Insertion (L, key)<br>
            local update [0...max-level+1]<br>
            a = L -> header<br>
            for i = L -> level down to a<br>
            while a -> forward [i]→ key forward [i]<br>
            update[i]=a<br>
            a = a + forward[a]<br>
            |V| = random-level() <br>
            if |V| > L -> level then<br>
            fOR i = L -> Level + 1 to |V| do <br>
            update [i]=L -> header<br>
            L -> level = |V|<br>
            a = make node (|V|, key, value)<br>
            for i = 0 to level do <br>
            a → Forward [i] = update[i] -> forward (i)<br>
            update [i] -> forward [i]= a<br>
        </p>
        <h2>Algorithm of deletion operation :-</h2>
        <p>Deletion (L, key)<br>
         local update (o... max-level + 1] <br>
         a = L+ header<br>
         for i=L -> level downs 0 to a<sub>o</sub><br>
         while a -> forward [i] → key forward [i]<br>
         update [i]=a<br>
         a = a -> forward [0]<br>
         if a -> key = key then<br>
         for i=0 to L -> level do<br>
         if update [i] -> forward [i] & a then break <br>
         update [i] ->  forward [i] → forward [i]<br>
         free (a)<br>
         while L -> level > 0 and 1 ->header ->Forword[L-> level] = NIL do<br>
         L -> level = L -> level-1<br>
        </p>
        <h2>Algorithm of searching operation :-</h2>
        <p>Searching (L, SKey)  <br>
            a = L → header  <br>
            loop invariant: a → key level down to 0 do. <br>
                 while a → forward[i] → key forward[i]  <br>
            a = a → forward[0]  <br>
           if a → key = SKey then return a → value  <br>
           else return failure  </p>
           <p><b>Example 1</b>: Create a skip list, we want to insert these following keys in the empty skip list<br>
            1. 6 with level 1.<br>
            2. 29 with level 1.<br>
            3. 22 with level 4.<br>
            4. 9 with level 3.<br>
            5. 17 with level 1.<br>
            6. 4 with level 2.<br><br>
            Ans:   <br> <b>Step 1</b>: Insert 6 with level 1<br>
          <img src="https://static.javatpoint.com/ds/images/skip-list-in-data-structure2.png"><br>
                 <b>Step 2</b>: Insert 29 with level 1<br>
          <img src="https://static.javatpoint.com/ds/images/skip-list-in-data-structure3.png"><br>
                 <b>Step 3</b>: Insert 22 with level 4<br>
          <img src="https://static.javatpoint.com/ds/images/skip-list-in-data-structure4.png"><br>
                 <b>Step 4</b>: Insert 9 with level 3<br>
          <img src="https://static.javatpoint.com/ds/images/skip-list-in-data-structure5.png"><br>
                 <b>Step 5</b>: Insert 17 with level 1<br>
          <img src="https://static.javatpoint.com/ds/images/skip-list-in-data-structure6.png"><br>
                 <b>Step 6</b>: Insert 4 with level 2<br>
          <img src="https://static.javatpoint.com/ds/images/skip-list-in-data-structure7.png"><br>
        </p>
        <h1>Stack</h1>
        <p>A Stack is a linear data structure that follows the LIFO (Last-In-First-Out) principle. Stack has one end, whereas the Queue has two ends (front and rear).<br>
           A stack can be defined as a container in which insertion and deletion can be done from the one end known as the top of the stack.<br>
           A Stack is an abstract data type with a pre-defined capacity, which means that it can store the elements of a limited size. </p>
           <h2>Operations on the stack :-</h2>
           <p>1. <b>push()</b>: When we insert an element in a stack then the operation is known as a push. If the stack is full then the<br> overflow condition occurs.<br>
            2. <b>pop()</b>: When we delete an element from the stack, the operation is known as a pop. If the stack is empty means<br> that no element exists in the stack, this state is known as an underflow state.<br>
            3. <b> peek()</b>: It returns the element at the given position.<br>
            4. <b>count()</b>: It returns the total number of elements available in a stack.<br>
            5. <b>change()</b>: It changes the element at the given position.<br>
            6. <b>display()</b>: It prints all the elements available in the stack.</p>
            <h2>PUSH operation</h2>
            <p>The steps involved in the PUSH operation is given below:<br>
               1. Before inserting an element in a stack, we check whether the stack is full.<br>
               2. If we try to insert the element in a stack, and the stack is full, then the overflow condition occurs.<br>
               3. When we initialize a stack, we set the value of top as -1 to check that the stack is empty.<br>
               4. When the new element is pushed in a stack, first, the value of the top gets incremented, <br>i.e., top=top+1, and the element will be placed at the new position of the top.<br>
               5. The elements will be inserted until we reach the max size of the stack.<br><br>
              <img src="https://static.javatpoint.com/ds/images/ds-stack2.png"></p>
            <h2>POP operation</h2>
            <p>The steps involved in the POP operation is given below:<br>
                1. Before deleting the element from the stack, we check whether the stack is empty.<br>
                2. If we try to delete the element from the empty stack, then the underflow condition occurs.<br>
                3. If the stack is not empty, we first access the element which is pointed by the top<br>
                4. Once the pop operation is performed, the top is decremented by 1, i.e., top=top-1.<br><br>
             <img src="https://static.javatpoint.com/ds/images/ds-stack3.png"></p>
             <h2>Applications of Stack</h2>
             <p>1. <b>Recursion</b>: The recursion means that the function is calling itself again. To maintain the previous states, <br>the compiler creates a system stack in which all the previous records of the function are maintained.<br>
                2.<b> DFS(Depth First Search)</b>: This search is implemented on a Graph, and Graph uses the stack data structure.<br>
                3. <b>Backtracking</b>: Suppose we have to create a path to solve a maze problem. If we are moving in a particular path, <br>and we realize that we come on the wrong way. In order to come at the beginning of the path to create a new path,<br> we have to use the stack data structure.<br>
                4.<b> Memory management</b>: The stack manages the memory. The memory is assigned in the contiguous memory blocks.<br> </p>
                <h2>Algorithm of push operation:-</h2><br>
                <p>begin<br>
                  if top=n then stack full<br>
                 top = top + 1<br>
                 stack(top) = item;<br>
                end<br><br>
                time Complexity : o(1)</p>
                <h2>Algorithm of pop operation:-</h2><br>
                <p>begin<br>
                 if top = 0 then empty<br>
                 item = stack(top);<br>
                 top = top-1;<br>
                 end<br><br>
                 time Complexity : o(1)</p>
                 <h1>Queue</h1>
                 <p> A queue can be defined as an ordered list which enables insert operations to be performed at one end called REAR<br> and delete operations to be performed at another end called FRONT.
                 Queue is referred to be as First In First Out list.</p>
                 <img src="https://static.javatpoint.com/ds/images/queue.png">
                 <h2>Complexity</h2>
                 <table border>
                    <tr>
                    <th>Data Structure</th>
                    <th colspan="8">Time Complexity</th>
                    <th>Space Compleity</th>
                    </tr>
                    <tr>
                    <td></td>
                    <td colspan="4"><strong>Average</strong></td>
                    <td colspan="4"><strong>Worst</strong></td>
                    <td><strong>Worst</strong></td>
                    </tr>
                    <tr>
                    <td></td>
                    <td>Access</td>
                    <td>Search</td>
                    <td>Insertion</td>
                    <td>Deletion</td>
                    <td>Access</td>
                    <td>Search</td>
                    <td>Insertion</td>
                    <td>Deletion</td>
                    <td></td>
                    </tr>
                    <tr>
                    <td>Queue</td>
                    <td>&theta;(n)</td>
                    <td>&theta;(n)</td>
                    <td>&theta;(1)</td>
                    <td>&theta;(1)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                    <td>O(n)</td>
                    </tr>
                    </table>
                    <h2>Operations performed on queue</h2>
                    <p>1. <b>Enqueue</b> The Enqueue operation is used to insert the element at the rear end of the queue. It returns void.<br>
                       2. <b>Dequeue</b>: It performs the deletion from the front-end of the queue. It also returns the element which has been removed from the front-end. It returns an integer value.<br>
                       3. <b>Peek</b>: This is the third operation that returns the element, which is pointed by the front pointer in the queue but does not delete it.<br>
                       4. <b>Queue overflow (isfull)</b>: It shows the overflow condition when the queue is completely full.<br>
                       5. <b>Queue underflow (isempty)</b>: It shows the underflow condition when the Queue is empty, i.e., no elements are in the Queue.
                    </p>
                       <h2>Types of Queue</h2>
                       <p><b>1. Linear Queue</b><br>In Linear Queue, an insertion takes place from one end while the deletion occurs from another end. The end at which the insertion <br>takes place is known as the rear end, and the end at which the deletion takes place is known as front end. It strictly follows the FIFO rule.<br>
                     <img src="https://static.javatpoint.com/ds/images/ds-types-of-queue3.png"> <br>
                     The elements are inserted from rear end, and if we insert mcrc elements in queue, then far ralust gers incremented on every insertion. drawback is uthing linear <br>queue is insertion is done only from year and. The linear queue shows. the overflow condition as rear is painating to last. clement of the queue.</p>
                      <h2>2. Circular Queue</h2><br>
                      <p>In circular queue, all nodes are represented as circular. It's similar to linear queue. except that last element of the queue is connected to the first element. It is also known as ring buffer. as all fools are connected to another end.
                        <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRo3nIe6hBHNsZYKG8DAd7oRG0XpGv0qIlLtA&usqp=CAU">      <br>          
                        Dhrowback of linear queue is overcomes in circular queue. It empty space is available, new element can be added is <br>empty space by simply increment value of rear.
                    </p>
                      <h2>Priority Queue</h2><br>
                      <p>The queue to which each element has some pipity associated with it. Based on Priority of the element, elements are <br>arranged in a priority
                        queue. If elements occur with same priority, then they are served according to FIFO principle.</p>
                        <h1>Array representation of Queue</h1>
                        <img src="https://static.javatpoint.com/ds/images/array-representation-of-queue.png"><br>
                        <p>After deleting an element, the value of front will increase from -1 to 0. however, the queue will look something like following.<br></p>
                        <img src="https://static.javatpoint.com/ds/images/array-representation-of-queue3.png"><br>
                        <h2>Algorithm to insert any element in a queue</h2>
                        <p><b>Step 1</b>: IF REAR = MAX - 1<br>
                            Write OVERFLOW<br>
                            Go to step<br>
                            [END OF IF]<br>
                           <b> Step 2</b>: IF FRONT = -1 and REAR = -1<br>
                            SET FRONT = REAR = 0<br>
                            ELSE<br>
                            SET REAR = REAR + 1<br>
                            [END OF IF]<br>
                            <b>Step 3</b>: Set QUEUE[REAR] = NUM<br>
                            <b>>Step 4</b: EXIT
                        </p>
                            <h2>Algorithm to delete an element from queue</h2><br>
                            <p><b>Step 1</b>: IF FRONT = -1 or FRONT > REAR<br>
                                Write UNDERFLOW<br>
                                ELSE<br>
                                SET VAL = QUEUE[FRONT]<br>
                                SET FRONT = FRONT + 1<br>
                                [END OF IF]<br>
                                <b>Step 2</b>: EXIT
                            </p>
				    
		  <a href="https://gungungupta7525.github.io/Data-structure/stack.html" style="font-size:30;"> <button>NEXT</button></a>
         </body>
</html>
	

